////////////////////////////////////////////////////////////////////////
// \file    SRParticle.h
////////////////////////////////////////////////////////////////////////
#ifndef SRPARTICLE_H
#define SRPARTICLE_H

#include <cstdint>
#include <TVector3.h>

/* #include "SRVector3D.h" */


namespace caf
{
  /// Representation of a simb::MCParticle, knows energy and direction, but not a list
  /// of hits.
  class SRParticle
    {
    public:
      /// Enum of walls of the detector
      enum Wall {
	wNone=0,
	wTop=1,
	wBottom=2,
	wLeft=3,
	wRight=4,
	wFront=5,
	wBack=6
      };

      /// Enum of G4 processes
      enum G4Process : int32_t;

      /// Enum of genie process
      enum GenieStatus : int32_t;

      TVector3 startp; //!< Start momentum of the particle (first point in the active TPC volume) [GeV/c]
      TVector3 endp;   //!< End momentum of the particle (last point in the active TPC volume) [GeV/c]
      float    startE; //!< Start energy of the particle (first point in the active TPC volume) [GeV]
      float    endE;   //!< End energy  of the particle (last point in the active TPC volume) [GeV]
      float    deposited_energy; //!< Total energy deposited in active volume [GeV]

      TVector3 start;  //!< Start position of the particle (first point in the active TPC volume) [cm]
      TVector3 end;    //!< End position of the particle (last point in the active TPC volume) [cm] 
      float start_time;//!< Start time of the particle (first point in the active TPC volume) [mus -- t=0 is spill time]
      float end_time;  //!< End time of the particle (last point in the active TPC volume) [mus -- t=0 is spill time]
      
      Wall wenter;     //!< Wall of cryostat particle enters (wNone if starting in detector)
      Wall wexit;      //!< Wall of cryostat particle exits (wNone if stopping in detector)

      bool contained_in_cryo; //!< Whether the particle is contained in a single cryostat
      bool contained_in_tpc;  //!< Whether the particle is contained in a single TPC
      bool crosses_tpc; //!< Whether the particle crosses a TPC boundary 
      bool is_contained; //!< Whether the particle is contained in a single active volume

      float length;     //!< Total trajectory length of particle contained in the active TPC volume [cm]
      int pdg;          //!< Particle ID code
      int G4ID;         //!< ID of the particle (taken from G4 -- -1 if this particle is not propogated by genie)
      G4Process start_process; //!< Start G4 process of the particle
      G4Process end_process; //!< End G4 process of the particle
      GenieStatus gstatus; //!< Status of the particle is generated by genie
      int interaction_id; //!< Neutrino interaction ID of the source of this particle (-1 if cosmic)

      /// Whether this is a primary particle or generated by a secondary interaction
      bool IsPrimary() const;

      /// Whether this particle should have a bragg peak in the detector
      bool HasBraggPeak() const;

      /// Whether this particle was generated by genie (as opposed to geant or corsika)
      bool IsGenie() const;

      /// Whether this is a stable particle as generated by genie
      bool IsStable() const;


      SRParticle();
      ~SRParticle(){  };

      /// Enum of genie process
      enum GenieStatus : int32_t {
	kIStUndefined                = -1,
	kIStInitialState             =  0,
	kIStStableFinalState         =  1,
	kIStIntermediateState        =  2,
	kIStDecayedState             =  3,
	kIStCorrelatedNucleon        = 10,
	kIStNucleonTarget            = 11,
	kIStDISPreFragmHadronicState = 12,
	kIStPreDecayResonantState    = 13,
	kIStHadronInTheNucleus       = 14,
	kIStFinalStateNuclearRemnant = 15,
	kIStNucleonClusterTarget     = 16,
        kNotGenie                    = 17 //!< Not a genie particle
      };


      /// Enum of G4 processes
      enum G4Process : int32_t {
	primary,
	CoupledTransportation,
	FastScintillation,
	Decay,
	anti_neutronInelastic,
	neutronInelastic,
	anti_protonInelastic,
	protonInelastic,
	hadInelastic,
	pipInelastic,
	pimInelastic,
	xipInelastic,
	ximInelastic,
	kaonpInelastic,
	kaonmInelastic,
	sigmapInelastic,
	sigmamInelastic,
	kaon0LInelastic,
	kaon0SInelastic,
	lambdaInelastic,
	anti_lambdaInelastic,
	He3Inelastic,
	ionInelastic,
	xi0Inelastic,
	alphaInelastic,
	tInelastic,
	dInelastic,
	anti_neutronElastic,
	neutronElastic,
	anti_protonElastic,
	protonElastic,
	hadElastic,
	pipElastic,
	pimElastic,
	kaonpElastic,
	kaonmElastic,
	conv,
	phot,
	annihil,
	nCapture,
	nKiller,
	muMinusCaptureAtRest,
	muIoni,
	eBrem,
	CoulombScat,
	hBertiniCaptureAtRest,
	hFritiofCaptureAtRest,
	photonNuclear,
	muonNuclear,
	electronNuclear,
	positronNuclear,
	compt,
	eIoni,
	muBrems,
	hIoni,
	muPairProd,
	hPairProd
      };


    };

} // end namespace

#endif // SRPARTICLE_H
//////////////////////////////////////////////////////////////////////////////
